<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>All Japan Kendo Championship Bracket</title>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 2em;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
        }

        .user-input {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        input[type="text"] {
            padding: 10px 15px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            width: 200px;
        }

        button {
            padding: 10px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: background 0.3s;
        }

        button:hover {
            background: #5568d3;
        }

        button.secondary {
            background: #48bb78;
        }

        button.secondary:hover {
            background: #38a169;
        }

        button.danger {
            background: #f56565;
        }

        button.danger:hover {
            background: #e53e3e;
        }

        .bracket-container {
            overflow-x: auto;
            margin-top: 30px;
        }

        .bracket {
            display: flex;
            gap: 60px;  /* <-- Changed from 40px */
            min-width: 1200px;
            padding: 20px;
        }

        .round {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: space-around;
        }

                .round-0 .matchup {
            margin: 5px 0;
        }

        .round-1 .matchup {
            margin: 20px 0;
        }

        .round-2 .matchup {
            margin: 60px 0;
        }

        .round-3 .matchup {
            margin: 140px 0;
        }

        .round-4 .matchup {
            margin: 300px 0;
        }

        .round-5 .matchup {
            margin: 620px 0;
        }

        .round-title {
            text-align: center;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.1em;
        }

        .matchup {
            background: #f7fafc;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            margin: 10px 0;
            padding: 8px;
            position: relative;
        }

        .round {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            position: relative;  /* <-- Added this */
        }

        /* Horizontal line extending from matchup to the right */
        .matchup::after {
            content: '';
            position: absolute;
            left: 100%;
            top: 50%;
            width: 20px;
            height: 2px;
            background: #cbd5e0;
        }

        /* Hide line for final round */
        .round:last-child .matchup::after {
            display: none;
        }

        /* Vertical connector between pairs of matches */
        .matchup.has-connector::before {
            content: '';
            position: absolute;
            left: calc(100% + 20px);
            top: 50%;
            width: 2px;
            background: #cbd5e0;
        }

        /* Top match of pair - line goes down */
        .matchup.connector-down::before {
            height: calc(100% + 10px + 50%);
        }

        /* Bottom match of pair - line goes up */
        .matchup.connector-up::before {
            height: calc(100% + 10px + 50%);
            bottom: 50%;
            top: auto;
        }

        .round:last-child .matchup::after {
            display: none;
        }

        .bracket-line {
            position: absolute;
            background: #cbd5e0;
        }

        .player {
            padding: 12px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            margin: 2px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .player:hover {
            background: #edf2f7;
        }

        .player.selected {
            background: #667eea;
            color: white;
            font-weight: 600;
        }

        .player.correct {
            background: #48bb78;
            color: white;
        }

        .player.incorrect {
            background: #f56565;
            color: white;
        }

        .player-name {
            flex: 1;
            font-weight: 600;
        }

        .prefecture {
            font-size: 0.8em;
            opacity: 0.7;
            margin-left: 8px;
        }

        .seed {
            font-size: 0.85em;
            opacity: 0.7;
            margin-right: 8px;
            font-weight: bold;
        }

        .leaderboard {
            margin-top: 40px;
            padding: 20px;
            background: #f7fafc;
            border-radius: 8px;
        }

        .leaderboard h2 {
            color: #333;
            margin-bottom: 20px;
            text-align: center;
        }

        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            padding: 12px;
            background: white;
            margin: 8px 0;
            border-radius: 6px;
            border-left: 4px solid #667eea;
        }

        .leaderboard-entry.top {
            border-left-color: #f6ad55;
            font-weight: 600;
        }

        .rank {
            font-weight: bold;
            color: #667eea;
            min-width: 40px;
        }

        .instructions {
            background: #edf2f7;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 0.95em;
            color: #555;
        }

        .mode-indicator {
            text-align: center;
            padding: 10px;
            background: #edf2f7;
            border-radius: 6px;
            margin-bottom: 20px;
            font-weight: 600;
            color: #667eea;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            overflow-y: auto;
        }

        .modal-content {
            background-color: white;
            margin: 50px auto;
            padding: 30px;
            border-radius: 12px;
            width: 90%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .close {
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            color: #999;
        }

        .close:hover {
            color: #333;
        }

        .bracket-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .bracket-item {
            padding: 15px;
            background: #f7fafc;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .bracket-item:hover {
            background: #edf2f7;
            transform: translateX(5px);
        }

        .bracket-info {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .bracket-name {
            font-weight: 600;
            font-size: 1.1em;
        }

        .bracket-date {
            font-size: 0.85em;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>All Japan Kendo Championship Bracket</h1>

        <div class="instructions">
            <strong>How to play:</strong> Enter your name, click through the bracket to make your predictions, then save your bracket. When the actual results are in, the leaderboard will show who had the closest bracket! Bracket will lock once tournament begins.
        </div>

        <div id="lockedNotice" class="locked-notice" style="display: none;">
            üîí Tournament has started! Bracket submissions are now locked.
        </div>

        <div class="controls">
            <div class="user-input">
                <input type="text" id="userName" placeholder="Enter your name" />
                <button onclick="app.saveBracket()">üíæ Save My Bracket</button>
            </div>
            <button onclick="app.viewAllBrackets()">üë• View All Brackets</button>
            <button onclick="app.toggleAdminMode()">‚öôÔ∏è Admin Mode</button>
            <button class="secondary" onclick="app.toggleLeaderboard()" id="leaderboardBtn">üèÜ View Leaderboard</button>
            <div id="bracketCount" style="padding: 10px 20px; background: #edf2f7; border-radius: 6px; font-weight: 600; color: #667eea;">
                üìä Loading...
            </div>
        </div>

        <div id="modeIndicator" class="mode-indicator" style="display: none;">
            <span id="modeText"></span>
            <button class="danger" onclick="app.clearAll()" style="margin-left: 20px;">üóëÔ∏è Clear All Data</button>
            <button onclick="app.toggleLock()" style="margin-left: 10px;" id="lockBtn">üîí Lock Submissions</button>
        </div>

        <div class="bracket-container">
            <div class="bracket" id="bracket"></div>
        </div>

        <div class="leaderboard" id="leaderboard" style="display: none;">
            <h2>üèÜ Leaderboard</h2>
            <div id="leaderboardContent"></div>
        </div>
    </div>

    <!-- Modal for viewing all brackets -->
    <div id="bracketsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>All Saved Brackets</h2>
                <span class="close" onclick="app.closeModal()">&times;</span>
            </div>
            <div id="bracketsList" class="bracket-list"></div>
        </div>
    </div>

    <script>
        // Initialize Firebase
        const firebaseConfig = {
            apiKey: "AIzaSyBYTFoMl-7yV6knvbHikVHRN8dlbyIil6A",
            authDomain: "kendo-bracket.firebaseapp.com",
            projectId: "kendo-bracket",
            storageBucket: "kendo-bracket.firebasestorage.app",
            messagingSenderId: "837468107917",
            appId: "1:837468107917:web:163051cf69519877cbdec4"
        };
        
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();

        const app = {
            players: [],
            bracket: {},
            adminMode: false,
            currentUser: '',
            actualResults: null,
            isLocked: false,
            
            async init() {
                this.generatePlayers();
                await this.checkLockStatus();
                this.renderBracket();
                this.updateLeaderboard();
                this.updateBracketCount();
            },

             generatePlayers() {
                const players = [
                    // Left side of bracket (32 players)
                    { name: 'Y.KUROKAWA', prefecture: 'Kanagawa', seed: 5 },
                    { name: 'T.CHIKAMOTO', prefecture: 'Aichi', seed: 5 },
                    { name: 'Y.YAMADA', prefecture: 'Nara', seed: 'R6' },
                    { name: 'Y.OKUMURA', prefecture: 'Hokkaido', seed: 5 },
                    { name: 'H.SOMEYA', prefecture: 'Chiba', seed: 5 },
                    { name: 'M.HATSUKANO', prefecture: 'Tottori', seed: 4 },
                    { name: 'K.SHIMOKUBO', prefecture: 'Miyazaki', seed: 'R6' },
                    { name: 'T.MORIMOTO', prefecture: 'Kagawa', seed: 'R6' },
                    { name: 'K.SENDA', prefecture: 'Miyagi', seed: 5 },
                    { name: 'R.KUNITOMO', prefecture: 'Fukuoka', seed: 'R6' },
                    { name: 'Y.NAKANE', prefecture: 'Ibaraki', seed: 5 },
                    { name: 'S.NISHIZAWA', prefecture: 'Nagano', seed: 5 },
                    { name: 'Y.TAKENOCHI', prefecture: 'Tokyo', seed: 6 },
                    { name: 'S.MAEDA', prefecture: 'Hyogo', seed: 6 },
                    { name: 'Y.MATSUOKA', prefecture: 'Mie', seed: 5 },
                    { name: 'R.KAMOI', prefecture: 'Okayama', seed: 5 },
                    { name: 'T.UEZU', prefecture: 'Okinawa', seed: 'R7' },
                    { name: 'K.TAKEMOTO', prefecture: 'Shiga', seed: 4 },
                    { name: 'R.NATSUMEDA', prefecture: 'Hiroshima', seed: 4 },
                    { name: 'H.HOSHINO', prefecture: 'Gunma', seed: 5 },
                    { name: 'T.YAMAZAKI', prefecture: 'Ishikawa', seed: 5 },
                    { name: 'N.TASHIRO', prefecture: 'Fukuoka', seed: 4 },
                    { name: 'Y.ITO', prefecture: 'Saitama', seed: 4 },
                    { name: 'H.ISHIDA', prefecture: 'Yamagata', seed: 5 },
                    { name: 'R.SEIKE', prefecture: 'Osaka', seed: 5 },
                    { name: 'K.MUKUNASHI', prefecture: 'Tokyo', seed: 5 },
                    { name: 'T.TAKADA', prefecture: 'Aomori', seed: 'R6' },
                    { name: 'K.KUSUNOKI', prefecture: 'Shimane', seed: 4 },
                    { name: 'R.SUZUKI', prefecture: 'Chiba', seed: 4 },
                    { name: 'E.KANASAKI', prefecture: 'Toyama', seed: 4 },
                    { name: 'M.KUROKI', prefecture: 'Oita', seed: 5 },
                    { name: 'T.MURAKAMI', prefecture: 'Ehime', seed: 'R6' },
                    
                    // Right side of bracket (32 players)
                    { name: 'K.NAKAZAWA', prefecture: 'Kochi', seed: 'R6' },
                    { name: 'S.MATSUI', prefecture: 'Tochigi', seed: 5 },
                    { name: 'K.MATSUZAKI', prefecture: 'Ibaraki', seed: 5 },
                    { name: 'T.NAGANO', prefecture: 'Hyogo', seed: 'R6' },
                    { name: 'S.HAMASAKI', prefecture: 'Kagoshima', seed: 6 },
                    { name: 'K.KUNIYASU', prefecture: 'Akita', seed: 5 },
                    { name: 'K.OKA', prefecture: 'Saga', seed: 5 },
                    { name: 'S.KANO', prefecture: 'Tokyo', seed: 6 },
                    { name: 'K.KIMURA', prefecture: 'Osaka', seed: 5 },
                    { name: 'H.SAKAMOTO', prefecture: 'Shimane', seed: 'R6' },
                    { name: 'K.HASHIMOTO', prefecture: 'Saitama', seed: 'R7' },
                    { name: 'K.HAYASHIDA', prefecture: 'Nagasaki', seed: 6 },
                    { name: 'S.OTANI', prefecture: 'Fukushima', seed: 'R6' },
                    { name: 'H.ABIRU', prefecture: 'Tokyo', seed: 4 },
                    { name: 'Y.KUDAMATSU', prefecture: 'Aichi', seed: 5 },
                    { name: 'M.TABATA', prefecture: 'Niigata', seed: 3 },
                    { name: 'H.NISHIMURA', prefecture: 'Kumamoto', seed: 'R7' },
                    { name: 'Y.YAMAGUCHI', prefecture: 'Yamanashi', seed: 6 },
                    { name: 'Y.NOMURA', prefecture: 'Kanagawa', seed: 'R7' },
                    { name: 'T.YAMURA', prefecture: 'Yamaguchi', seed: 5 },
                    { name: 'K.HOSHIKO', prefecture: 'Tokyo', seed: 5 },
                    { name: 'T.TSURUHAMA', prefecture: 'Osaka', seed: 2 },
                    { name: 'Y.ITO', prefecture: 'Gifu', seed: 5 },
                    { name: 'S.IZAWA', prefecture: 'Hokkaido', seed: 6 },
                    { name: 'Y.SASAKI', prefecture: 'Chiba', seed: 5 },
                    { name: 'R.NISHIDA', prefecture: 'Tokushima', seed: 6 },
                    { name: 'S.OGURA', prefecture: 'Wakayama', seed: 5 },
                    { name: 'M.FURUDATE', prefecture: 'Iwate', seed: 'R7' },
                    { name: 'S.AREMATSU', prefecture: 'Saitama', seed: 6 },
                    { name: 'S.TOMITA', prefecture: 'Fukui', seed: 6 },
                    { name: 'R.GOYA', prefecture: 'Kyoto', seed: 'R6' },
                    { name: 'R.IKEDA', prefecture: 'Fukuoka', seed: 4 }
                ];

                this.players = players.map((p, i) => ({
                    id: i + 1,
                    ...p
                }));
            },

            async checkLockStatus() {
                try {
                    const lockDoc = await db.collection('settings').doc('tournament').get();
                    if (lockDoc.exists) {
                        this.isLocked = lockDoc.data().locked || false;
                        if (this.isLocked) {
                            document.getElementById('lockedNotice').style.display = 'block';
                        }
                    }
                } catch (error) {
                    console.error('Error checking lock status:', error);
                }
            },

            async updateBracketCount() {
                try {
                    const bracketsSnapshot = await db.collection('brackets').get();
                    const count = bracketsSnapshot.size;
                    document.getElementById('bracketCount').textContent = `üìä ${count} Bracket${count !== 1 ? 's' : ''} Submitted`;
                } catch (error) {
                    console.error('Error counting brackets:', error);
                    document.getElementById('bracketCount').textContent = 'üìä Error loading count';
                }
            },

            async toggleLock() {
                try {
                    this.isLocked = !this.isLocked;
                    
                    await db.collection('settings').doc('tournament').set({
                        locked: this.isLocked,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    
                    const lockBtn = document.getElementById('lockBtn');
                    const lockedNotice = document.getElementById('lockedNotice');
                    
                    if (this.isLocked) {
                        lockBtn.textContent = 'üîì Unlock Submissions';
                        lockedNotice.style.display = 'block';
                        alert('Tournament locked! Users can no longer submit or modify brackets.');
                    } else {
                        lockBtn.textContent = 'üîí Lock Submissions';
                        lockedNotice.style.display = 'none';
                        alert('Tournament unlocked! Users can now submit brackets again.');
                    }
                } catch (error) {
                    alert('Error toggling lock: ' + error.message);
                }
            },

            saveBracket() {
                if (this.isLocked && !this.adminMode) {
                    alert('Tournament is locked! Bracket submissions are no longer allowed.');
                    return;
                }
                
                const userName = document.getElementById('userName').value.trim();
                if (!userName) {
                    alert('Please enter your name!');
                    return;
                }

                // Save to Firebase Firestore
                db.collection('brackets').doc(userName).set({
                    predictions: this.bracket,
                    timestamp: firebase.firestore.FieldValue.serverTimestamp()
                }).then(() => {
                    alert(`Bracket saved for ${userName}!`);
                    
                    // Clear name and bracket after saving
                    document.getElementById('userName').value = '';
                    this.bracket = {};
                    this.currentUser = '';
                    this.renderBracket();
                    this.updateBracketCount();
                }).catch((error) => {
                    alert('Error saving bracket: ' + error.message);
                });
            },

            async loadFromFirebase() {
                try {
                    // Check if actual results exist
                    const resultsDoc = await db.collection('actualResults').doc('current').get();
                    if (resultsDoc.exists) {
                        document.getElementById('leaderboardBtn').style.display = 'inline-block';
                    }
                } catch (error) {
                    console.error('Error loading from Firebase:', error);
                }
            },

            async toggleAdminMode() {
                if (!this.adminMode) {
                    // Trying to enter admin mode - require password
                    const password = prompt('Enter admin password:');
                    if (password !== 'kendo2025') {
                        alert('Incorrect password!');
                        return;
                    }
                    this.adminMode = true;
                    
                    // Clear name and bracket when entering admin mode
                    document.getElementById('userName').value = '';
                    this.currentUser = '';
                    
                    // Update lock button text based on current status
                    const lockBtn = document.getElementById('lockBtn');
                    lockBtn.textContent = this.isLocked ? 'üîì Unlock Submissions' : 'üîí Lock Submissions';
                    
                    // Load actual results from Firebase if they exist
                    try {
                        const resultsDoc = await db.collection('actualResults').doc('current').get();
                        if (resultsDoc.exists) {
                            this.bracket = resultsDoc.data().predictions || {};
                        } else {
                            this.bracket = {};
                        }
                    } catch (error) {
                        console.error('Error loading results:', error);
                        this.bracket = {};
                    }
                } else {
                    // Exiting admin mode
                    this.adminMode = false;
                    
                    // Clear name and bracket when exiting admin mode
                    document.getElementById('userName').value = '';
                    this.bracket = {};
                    this.currentUser = '';
                }
                
                const indicator = document.getElementById('modeIndicator');
                const modeText = document.getElementById('modeText');
                if (this.adminMode) {
                    modeText.textContent = '‚öôÔ∏è ADMIN MODE - Enter Actual Results';
                    indicator.style.display = 'flex';
                    indicator.style.justifyContent = 'center';
                    indicator.style.alignItems = 'center';
                } else {
                    indicator.style.display = 'none';
                }
                this.renderBracket();
            },

            async clearAll() {
                if (confirm('Are you sure you want to clear ALL data? This cannot be undone!')) {
                    try {
                        // Delete all brackets
                        const bracketsSnapshot = await db.collection('brackets').get();
                        const deletePromises = [];
                        bracketsSnapshot.forEach(doc => {
                            deletePromises.push(doc.ref.delete());
                        });
                        
                        // Delete actual results
                        deletePromises.push(db.collection('actualResults').doc('current').delete());
                        
                        await Promise.all(deletePromises);
                        
                        this.bracket = {};
                        this.adminMode = false;
                        document.getElementById('userName').value = '';
                        this.renderBracket();
                        this.updateLeaderboard();
                        this.updateBracketCount();
                        alert('All data cleared!');
                    } catch (error) {
                        alert('Error clearing data: ' + error.message);
                    }
                }
            },

            selectWinner(round, matchup, playerId) {
                if (!this.bracket[round]) {
                    this.bracket[round] = {};
                }
                this.bracket[round][matchup] = playerId;

                if (this.adminMode) {
                    // Save actual results to Firebase
                    db.collection('actualResults').doc('current').set({
                        predictions: this.bracket,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp()
                    }).then(() => {
                        this.updateLeaderboard();
                    }).catch((error) => {
                        console.error('Error saving results:', error);
                    });
                }

                this.renderBracket();
            },

            getRoundMatches(round) {
                // Round 0 (Round of 64): 32 matches with 64 players
                // Round 1 (Round of 32): 16 matches
                // Round 2 (Round of 16): 8 matches
                // Round 3 (Quarterfinals): 4 matches
                // Round 4 (Semifinals): 2 matches
                // Round 5 (Finals): 1 match
                const matchCount = 32 / Math.pow(2, round);
                const matches = [];

                for (let i = 0; i < matchCount; i++) {
                    if (round === 0) {
                        matches.push({
                            player1: this.players[i * 2],
                            player2: this.players[i * 2 + 1]
                        });
                    } else {
                        const prevRound = round - 1;
                        const match1 = i * 2;
                        const match2 = i * 2 + 1;
                        
                        const winner1 = this.bracket[prevRound]?.[match1];
                        const winner2 = this.bracket[prevRound]?.[match2];

                        matches.push({
                            player1: winner1 ? this.players.find(p => p.id === winner1) : null,
                            player2: winner2 ? this.players.find(p => p.id === winner2) : null
                        });
                    }
                }

                return matches;
            },

            renderBracket() {
                const bracketDiv = document.getElementById('bracket');
                const rounds = ['Round of 64', 'Round of 32', 'Round of 16', 'Quarterfinals', 'Semifinals', 'Finals'];
                
                let html = '';

                for (let round = 0; round < 6; round++) {
                    const matches = this.getRoundMatches(round);
                    html += `<div class="round round-${round}">`;
                    html += `<div class="round-title">${rounds[round]}</div>`;

                    matches.forEach((match, matchIndex) => {
                        // Determine if this match needs connectors
                        let connectorClass = '';
                        if (round < 5) { // Not the final round
                            if (matchIndex % 2 === 0) {
                                // Top match of pair
                                connectorClass = 'has-connector connector-down';
                            } else {
                                // Bottom match of pair
                                connectorClass = 'has-connector connector-up';
                            }
                        }
                        
                        html += `<div class="matchup ${connectorClass}">`;
                        
                        if (match.player1) {
                            const isSelected = this.bracket[round]?.[matchIndex] === match.player1.id;
                            const classes = this.getPlayerClasses(round, matchIndex, match.player1.id, isSelected);
                            html += `<div class="player ${classes}" onclick="app.selectWinner(${round}, ${matchIndex}, ${match.player1.id})">
                                <span class="seed">${match.player1.seed}</span>
                                <span class="player-name">${match.player1.name}</span>
                                <span class="prefecture">${match.player1.prefecture}</span>
                            </div>`;
                        } else {
                            html += `<div class="player" style="opacity: 0.3;">TBD</div>`;
                        }

                        if (match.player2) {
                            const isSelected = this.bracket[round]?.[matchIndex] === match.player2.id;
                            const classes = this.getPlayerClasses(round, matchIndex, match.player2.id, isSelected);
                            html += `<div class="player ${classes}" onclick="app.selectWinner(${round}, ${matchIndex}, ${match.player2.id})">
                                <span class="seed">${match.player2.seed}</span>
                                <span class="player-name">${match.player2.name}</span>
                                <span class="prefecture">${match.player2.prefecture}</span>
                            </div>`;
                        } else {
                            html += `<div class="player" style="opacity: 0.3;">TBD</div>`;
                        }

                        html += `</div>`;
                    });

                    html += `</div>`;
                }

                bracketDiv.innerHTML = html;
            },

            getPlayerClasses(round, matchIndex, playerId, isSelected) {
                let classes = '';
                if (isSelected) classes += 'selected ';

                if (!this.adminMode && this.actualResults) {
                    if (this.actualResults[round]?.[matchIndex]) {
                        if (this.actualResults[round][matchIndex] === playerId) {
                            classes += 'correct';
                        } else if (isSelected) {
                            classes += 'incorrect';
                        }
                    }
                }

                return classes;
            },

            async updateLeaderboard() {
                try {
                    // Load actual results from Firebase
                    const resultsDoc = await db.collection('actualResults').doc('current').get();
                    if (!resultsDoc.exists) {
                        // No results yet - show empty message
                        document.getElementById('leaderboardContent').innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">No results entered yet. Leaderboard will appear once the admin enters tournament results.</p>';
                        this.actualResults = null;
                        return;
                    }

                    const actualResults = resultsDoc.data().predictions || {};
                    this.actualResults = actualResults;
                    
                    // Load all brackets from Firebase
                    const bracketsSnapshot = await db.collection('brackets').get();
                    
                    if (bracketsSnapshot.empty) {
                        document.getElementById('leaderboardContent').innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">No brackets submitted yet.</p>';
                        return;
                    }
                    
                    const scores = [];

                    bracketsSnapshot.forEach(doc => {
                        const data = doc.data();
                        let score = 0;
                        let roundPoints = [1, 2, 4, 8, 16, 32]; // Points per round

                        for (let round = 0; round < 6; round++) {
                            const userPicks = data.predictions[round] || {};
                            const actual = actualResults[round] || {};

                            Object.keys(actual).forEach(matchup => {
                                if (userPicks[matchup] === actual[matchup]) {
                                    score += roundPoints[round];
                                }
                            });
                        }

                        scores.push({ name: doc.id, score });
                    });

                    scores.sort((a, b) => b.score - a.score);

                    let html = '';
                    scores.forEach((entry, index) => {
                        const topClass = index < 3 ? 'top' : '';
                        const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : '';
                        html += `<div class="leaderboard-entry ${topClass}">
                            <span><span class="rank">#${index + 1}</span> ${medal} ${entry.name}</span>
                            <span><strong>${entry.score}</strong> points</span>
                        </div>`;
                    });

                    document.getElementById('leaderboardContent').innerHTML = html;
                    
                    // Re-render bracket to show correct/incorrect picks
                    this.renderBracket();
                } catch (error) {
                    console.error('Error updating leaderboard:', error);
                    document.getElementById('leaderboardContent').innerHTML = '<p style="text-align: center; color: #ff0000;">Error loading leaderboard</p>';
                }
            },

            toggleLeaderboard() {
                const leaderboard = document.getElementById('leaderboard');
                if (leaderboard.style.display === 'none') {
                    leaderboard.style.display = 'block';
                    leaderboard.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                } else {
                    leaderboard.style.display = 'none';
                }
            },

            async viewAllBrackets() {
                // Clear name and bracket
                document.getElementById('userName').value = '';
                this.bracket = {};
                this.currentUser = '';
                this.renderBracket();
                
                const bracketsList = document.getElementById('bracketsList');
                
                try {
                    const bracketsSnapshot = await db.collection('brackets').get();
                    
                    if (bracketsSnapshot.empty) {
                        bracketsList.innerHTML = '<p style="text-align: center; color: #666;">No brackets saved yet!</p>';
                    } else {
                        let html = '';
                        bracketsSnapshot.forEach(doc => {
                            const data = doc.data();
                            const name = doc.id;
                            const date = data.timestamp ? data.timestamp.toDate().toLocaleString() : 'Unknown date';
                            html += `<div class="bracket-item" onclick="app.loadSpecificBracket('${name}')">
                                <div class="bracket-info">
                                    <div class="bracket-name">${name}</div>
                                    <div class="bracket-date">Saved: ${date}</div>
                                </div>
                                <button onclick="event.stopPropagation(); app.loadSpecificBracket('${name}')">View ‚Üí</button>
                            </div>`;
                        });
                        bracketsList.innerHTML = html;
                    }
                } catch (error) {
                    bracketsList.innerHTML = '<p style="text-align: center; color: #ff0000;">Error loading brackets</p>';
                    console.error('Error loading brackets:', error);
                }
                
                document.getElementById('bracketsModal').style.display = 'block';
            },

            async loadSpecificBracket(userName) {
                try {
                    const docRef = await db.collection('brackets').doc(userName).get();
                    if (docRef.exists) {
                        const data = docRef.data();
                        this.bracket = data.predictions;
                        this.currentUser = userName;
                        document.getElementById('userName').value = userName;
                        this.renderBracket();
                        this.closeModal();
                    }
                } catch (error) {
                    console.error('Error loading bracket:', error);
                    alert('Error loading bracket');
                }
            },

            closeModal() {
                document.getElementById('bracketsModal').style.display = 'none';
            }
        };

        // Initialize the app
        app.init();

        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('bracketsModal');
            if (event.target == modal) {
                app.closeModal();
            }
        }
    </script>
</body>
</html>
